/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => FolderFocusModePlugin
});
var import_obsidian2 = __toModule(require("obsidian"));

// settings.ts
var import_obsidian = __toModule(require("obsidian"));
var FolderFocusModeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Auto-Focus when hidden").setDesc("Ensures the plugin focuses automatically on directory of newly opened files, if they are not visible right now").addToggle((component) => component.setValue(this.plugin.settings.autofocusMode).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autofocusMode = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Auto-Focus on root").setDesc("Focus on the first folder from root if the auto focus setting is enabled").addToggle((component) => component.setValue(this.plugin.settings.autofocusRoot).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autofocusRoot = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Button on explorer").setDesc("Add a button on the top of the file explorer (Need Reloading to work)").addToggle((component) => component.setValue(this.plugin.settings.focusButton).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.focusButton = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Folder Note : External files").setDesc("Focus on the folder linked with the folder note").addToggle((component) => component.setValue(this.plugin.settings.focusNote).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.focusNote = value;
      yield this.plugin.saveSettings();
    })));
  }
};

// util.ts
var normalizeArray = (parts, allowAboveRoot) => {
  const res = [];
  for (let i = 0; i < parts.length; i++) {
    const p = parts[i];
    if (!p || p === ".")
      continue;
    if (p === "..") {
      if (res.length && res[res.length - 1] !== "..") {
        res.pop();
      } else if (allowAboveRoot) {
        res.push("..");
      }
    } else {
      res.push(p);
    }
  }
  return res;
};
var trimArray = (arr) => {
  const lastIndex = arr.length - 1;
  let start = 0;
  for (; start <= lastIndex; start++) {
    if (arr[start])
      break;
  }
  let end = lastIndex;
  for (; end >= 0; end--) {
    if (arr[end])
      break;
  }
  if (start === 0 && end === lastIndex)
    return arr;
  if (start > end)
    return [];
  return arr.slice(start, end + 1);
};
var resolve = (path) => {
  let resolvedPath = "", resolvedAbsolute;
  resolvedPath = path + "/" + resolvedPath;
  resolvedAbsolute = path[0] === "/";
  resolvedPath = normalizeArray(resolvedPath.split("/"), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
};
var getRelativePath = (from, to) => {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);
  const fromParts = trimArray(from.split("/"));
  const toParts = trimArray(to.split("/"));
  const length = Math.min(fromParts.length, toParts.length);
  let samePartsLength = length;
  for (let i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }
  let outputParts = [];
  for (let i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
};
var isAbsolutePath = (path) => {
  return path.charAt(0) === "/";
};
var getDirname = (path) => {
  return path.substring(0, path.lastIndexOf("/"));
};
var getRootDirname = (path) => {
  return path.substring(0, path.indexOf("/"));
};

// main.ts
var DEFAULT_SETTINGS = {
  autofocusMode: true,
  autofocusRoot: false,
  focusButton: false,
  focusNote: false
};
var FolderFocusModePlugin = class extends import_obsidian2.Plugin {
  shouldBeVisible(newFocusFolder, currentFolder) {
    const relative = getRelativePath(newFocusFolder, currentFolder);
    console.log(relative);
    const stringSplits = newFocusFolder.split("/");
    const parentsArray = stringSplits.reduce((acc, val, i) => {
      if (i === 0)
        return [val];
      acc.push(acc[i - 1] + "/" + val);
      return acc;
    }, []);
    console.log(parentsArray);
    return relative && !relative.startsWith("..") && !isAbsolutePath(relative) || parentsArray.includes(currentFolder) || currentFolder === "/";
  }
  hideTreeElements(newFocusFolder) {
    this.focusModeEnabled = true;
    this.focusModePath = newFocusFolder;
    const fileExplorers = this.app.workspace.getLeavesOfType("file-explorer");
    fileExplorers.forEach((fileExplorer) => {
      for (const key in fileExplorer.view.fileItems) {
        if (fileExplorer.view.fileItems.hasOwnProperty(key)) {
          if (this.shouldBeVisible(newFocusFolder, key)) {
            fileExplorer.view.fileItems[key].el.classList.remove("hidden-tree-element");
          } else {
            fileExplorer.view.fileItems[key].el.classList.add("hidden-tree-element");
          }
        }
      }
      const existingButton = FolderFocusModePlugin.getFocusButton(fileExplorer);
      if (existingButton) {
        this.unfocusedButton(existingButton);
      }
    });
  }
  showAllTreeElements() {
    this.focusModeEnabled = false;
    this.focusModePath = null;
    const fileExplorers = this.app.workspace.getLeavesOfType("file-explorer");
    fileExplorers.forEach((fileExplorer) => {
      for (const key in fileExplorer.view.fileItems) {
        if (fileExplorer.view.fileItems.hasOwnProperty(key)) {
          fileExplorer.view.fileItems[key].el.classList.remove("hidden-tree-element");
        }
      }
      const existingButton = FolderFocusModePlugin.getFocusButton(fileExplorer);
      if (existingButton) {
        this.focusedButton(existingButton);
      }
    });
  }
  getDirRoot(file) {
    if (this.settings.focusNote) {
      const linkedFolder = this.app.vault.getAbstractFileByPath(file.path.replace(".md", ""));
      if (linkedFolder && linkedFolder instanceof import_obsidian2.TFolder) {
        return linkedFolder.path;
      } else {
        return this.settings.autofocusRoot ? getRootDirname(file.path) : getDirname(file.path);
      }
    } else {
      return this.settings.autofocusRoot ? getRootDirname(file.path) : getDirname(file.path);
    }
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  onload() {
    return __async(this, null, function* () {
      console.log("focus folder loaded");
      yield this.loadSettings();
      this.addSettingTab(new FolderFocusModeSettingTab(this.app, this));
      this.focusModeEnabled = false;
      if (this.settings.focusButton) {
        this.app.workspace.onLayoutReady(() => {
          const explorers = this.getFileExplorers();
          explorers.forEach((exp) => {
            this.addFocusFolderButton(exp);
          });
        });
      }
      this.registerEvent(this.app.workspace.on("layout-change", () => {
        const explorers = this.getFileExplorers();
        explorers.forEach((exp) => {
          this.addFocusFolderButton(exp);
        });
      }));
      this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
        if (!(file == null ? void 0 : file.extension)) {
          const isCurrentlyFocused = this.focusModePath === file.path;
          menu.addItem((item) => {
            item.setTitle(isCurrentlyFocused ? "Unfocus" : "Focus on this folder").setIcon("eye").onClick(() => __async(this, null, function* () {
              if (isCurrentlyFocused) {
                this.showAllTreeElements();
              } else {
                this.hideTreeElements(file.path);
              }
            }));
          });
        }
      }));
      this.registerEvent(this.app.workspace.on("file-open", (file) => {
        console.log("Autofocus ?", this.settings.autofocusMode);
        if (this.focusModeEnabled && this.settings.autofocusMode && !this.shouldBeVisible(this.focusModePath, file.path)) {
          const currentFolderPath = this.getDirRoot(file);
          console.log(currentFolderPath);
          this.hideTreeElements(currentFolderPath);
          const explorers = this.getFileExplorers();
          explorers.forEach((exp) => {
            const container = exp.view.containerEl;
            const navContainer = container.querySelector("div.nav-buttons-container");
            if (!navContainer) {
              return null;
            }
            const existingButton = FolderFocusModePlugin.getFocusButton(exp);
            existingButton.classList.add("focus-close");
            this.addFocusFolderButton(exp);
          });
        }
      }));
      this.addCommand({
        id: "folder-focus-mode-unfocus",
        name: "Disable folder focus mode",
        callback: () => {
          this.showAllTreeElements();
        }
      });
      this.addCommand({
        id: "folder-focus-mode-toggle-autofocus",
        name: "Toggle autofocus mode",
        callback: () => {
          this.settings.autofocusMode = !this.settings.autofocusMode;
        }
      });
      this.addCommand({
        id: "folder-focus-mode-focus-active",
        name: "Enable folder focus mode for active file",
        checkCallback: (checking) => {
          const currentFile = this.app.workspace.getActiveFile();
          if (currentFile) {
            if (!checking) {
              const currentFolderPath = getDirname(currentFile.path);
              this.hideTreeElements(currentFolderPath);
            }
            return true;
          }
          return false;
        }
      });
    });
  }
  onunload() {
    console.log("focus folder unloaded");
    const explorers = this.getFileExplorers();
    explorers.forEach((exp) => {
      FolderFocusModePlugin.removeFocusFolderButton(exp);
    });
  }
  getFileExplorers() {
    return this.app.workspace.getLeavesOfType("file-explorer");
  }
  static getFocusButton(explorer) {
    return explorer.view.containerEl.querySelector(".focus-folder-button");
  }
  focusedButton(icon) {
    (0, import_obsidian2.setIcon)(icon, "eye");
    icon.classList.remove("focus-close");
    icon.classList.add("focus-open");
    icon.setAttribute("aria-label", "Focus on this file folder");
  }
  unfocusedButton(icon) {
    (0, import_obsidian2.setIcon)(icon, "eye-off");
    icon.classList.remove("focus-open");
    icon.classList.add("focus-close");
    icon.setAttribute("aria-label", "Unfocus folder");
  }
  addFocusFolderButton(explorer) {
    const container = explorer.view.containerEl;
    const navContainer = container.querySelector("div.nav-buttons-container");
    if (!navContainer) {
      return null;
    }
    const existingButton = FolderFocusModePlugin.getFocusButton(explorer);
    if (existingButton) {
      return;
    }
    const newIcon = document.createElement("div");
    (0, import_obsidian2.setIcon)(newIcon, "eye");
    newIcon.setAttribute("aria-label", "Focus on this file folder");
    newIcon.classList.add("nav-action-button", "focus-folder-button", "focus-open", "clickable-icon");
    this.registerDomEvent(newIcon, "click", () => {
      const currentFile = this.app.workspace.getActiveFile();
      if (currentFile) {
        const isCurrentlyFocused = this.focusModePath === currentFile.path;
        if (isCurrentlyFocused) {
          this.showAllTreeElements();
          this.focusedButton(newIcon);
        } else if (newIcon.classList.contains("focus-open")) {
          const currentFolderPath = this.getDirRoot(currentFile);
          this.hideTreeElements(currentFolderPath);
          this.unfocusedButton(newIcon);
        } else if (newIcon.classList.contains("focus-close")) {
          this.showAllTreeElements();
          this.focusedButton(newIcon);
        }
      }
    });
    navContainer.appendChild(newIcon);
  }
  static removeFocusFolderButton(explorer) {
    const button = FolderFocusModePlugin.getFocusButton(explorer);
    if (button) {
      button.remove();
    }
  }
};
